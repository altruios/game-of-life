//conways game of life


//rules 1 
//rule 2
//rule 3
//rule 4
<body id="body">
<canvas id="canvas" class="canvas"></canvas>
<div id="source" visibility="hidden">
	<p>this is all from <a href="https://www.conwaylife.com/ref/lexicon/lex_home.htm">https://www.conwaylife.com/ref/lexicon/lex_home.htm</a></p>
	<p>they have fantastic work done.</p>
	<p>I am still working on lining up the names with the correct shapes, that's a work in progress</p>
	<p>the text here has been pruded a bit to pass into the parser I wrote a little easier.</p>
	<p>the full text can be found at:<a href="https://www.conwaylife.com/"> https://www.conwaylife.com/</a></p>

</div>
<script src="artParser.js"></script>
<script>
const canvas = document.querySelector('canvas');
canvas.height = 1080;
canvas.width = 1920;
const cellScale = 4;
const ctx = canvas.getContext('2d');
const savePath = "/images";
source.style.maxHeight = "100vh";
 //defined in artparser
source.style.overflow = "scroll";

function saveImage(count,path) 
	{
	var canvasData = canvas.toDataURL("image/png");
	let sendObject = 
		{
		imageData: canvasData,
		filePath:path,
		count:count
	}	
  var xmlHttpReq = false;

  if (window.XMLHttpRequest) 
  	{
    ajax = new XMLHttpRequest();
  }
  else if (window.ActiveXObject) 
  	{
    ajax = new ActiveXObject("Microsoft.XMLHTTP");
  }

  ajax.open("POST", "saveimage.php", false);
  ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  ajax.onreadystatechange = function() 	
  	{
  }
  let save = false;
  ajax.send("imageBitmap="+sendObject.imageData+"&count="+sendObject.count+"&filePath="+sendObject.filePath);
  
  	return true;
}
function createButton(html, fn)
	{
	console.log(fn);	
	const button = document.createElement('button');
	button.innerHTML = html;
	button.addEventListener('click', function()
		{
		fn();

	});
	return button;
}
function* itteration()
	{
	let itter = 0;
	yield itter;	
	while (true)
		{
		itter++;
		yield itter;
	}
}


let itterator = itteration();

let createCell = function(state, position, column, row, cancerRate)
	{
	let rState = 0	
	if(state > 0.96)
		{
		rState = 1;	
	}
	let rCaner = 0;
	if(cancerRate > 0.7704)
		{
		rCaner = 1;
	}	
	let cell = 
		{	
		state: rState,
		neighbors: [],
		x: position.x,
		y: position.y,
		row: row,
		column: column,
		cancer:rCaner,
		cancerCount:0,
		id: itterator.next().value,
		draw: function(what)
			{
			if(what)
				{
				if(what == 1)
					{
					ctx.fillStyle  = "#000000";
					if(cell.cancer)
						{
						ctx.fillStyle = "#ff00f0";
					}
				}
				else{
					ctx.fillStyle  = "#ffffff";
						if(cell.cancer)
						{
						ctx.fillStyle = "#ff00f0";
					}
				}
			}	
			else
				{
				if(cell.state == 1)
					{
					ctx.fillStyle  = "#000000";
					if(cell.cancer)
						{
						ctx.fillStyle = "#ff00f0";
					}
				}
				else
					{
					ctx.fillStyle  = "#ffffff";
						if(cell.cancer)
						{
						ctx.fillStyle = "#ff00f0";
					}
				}
			}
			ctx.fillRect(cell.x, cell.y, cellScale, cellScale);
			ctx.stroke();
		},
		updateFriends:function()
			{
			this.neighbors.forEach((container)=> 
				{
				container[0] = container[1].state;
				container[2] = container[1].cancer;
			});	
		},
		gameOfLife: function(cancerR)
			{
			let changeToGameOfCancer = false;	
			let value = total(cell.neighbors.map(x=> x[0])); //the value is the last snapshot of the neighbor grid	
			let rState = 0; 
			let cancerCheck = total(cell.neighbors.map(x=>x[2]));
			if(cell.state == 1) //alive rules
				{
				if(cancerCheck > 0)
					{	
					let friendContainer = cell.neighbors.find(container=>container[2] == 1);
					//	friendContainer[2] = 0;
					let friendCancer = total(friendContainer[1].neighbors.map(x=> x[2]));
					if(friendCancer > 1)
						{
						changeToGameOfCancer = true;	
					}
				}	
				rState = 1;	//staying alive
				if(value > 3 || value <= 1)//unless overcrowded, or under-fed 
					{
					rState = 0;
				}
			}
			else 
				{	
				if(value == 3)
					{
					if(cancerCheck==3){changeToGameOfCancer= true}	
					rState = 1; //be alive only if 3 or more neighbors are alive

				}
				else if(cancerCheck == 2)
						{
						changeToGameOfCancer = true;
					}
				else if(cancerCheck==1)
					{		
					let friendContainer = cell.neighbors.find(container=>container[2] == 1);	
					let friendCancer = total(friendContainer[1].neighbors.map(x=>x[2]));	
					 if(friendCancer > value)
							{
							changeToGameOfCancer = true;
						}

					}
		}
		
			if(changeToGameOfCancer)
				{
				cell.cancer = 1;
			}
			return rState;
		},
		gameOfCancer: function()
			{
			let value = total(cell.neighbors.map(x=> x[0])); //the value is the last snapshot of the neighbor grid		
			let rCancerState = 0;
			let stillCancer = false;
			let cancerCheck = total(cell.neighbors.map(x=>x[2]));
			let friendsCancerCount = 0;
			cell.neighbors.forEach(neighbor=> friendsCancerCount += neighbor[1].neighbors.filter(x=>x[2] === 1).length);
			if(value < cancerCheck || cell.cancercount == 0)
				{
				stillCancer = true;
			}

			if(stillCancer)
				{
				if(cell.cancerCount > 0)
					{
					rCancerState = 0;
					cell.cancer = 0;
					cell.cancerCount = 0;
				}
				else
					{	
					rCancerState = 1;
					cell.cancer = 1;
					cell.cancerCount++;
				}
			}
			else
				{
				if(cell.cancerCount > 2)
					{
					rCancerState = 1;		
				}	
				cell.cancer = 0;
				cell.canerCount = 0;
			}
			return rCancerState

		
		},
		setSeededCancer:function(seed)
			{
			if(cell.state ==1 )
				{	
				if(seed>Math.random())
					{
					cell.cancer = 1;
					cell.draw();
				}
			}
		}
	}
	return cell;
}
let board = function(height, width)
	{
	let b = 
		{	
		gameMatrix: [],
		cancerRate:0,
		saveCount:9999,
		wipe:function()
			{
			ctx.fillStyle  = "#ffffff";
			ctx.fillRect(0,0, height*cellScale, width*cellScale);
			b.gameMatrix.forEach((cellArray)=>
				{
				cellArray.forEach((cell)=> 
					{
					cell.state=0;
					cell.neighbors.forEach(x=>x[0] = 0);
					cell.draw(0);
				});
			});
		},
		createGlider:function()
			{
			let randCol = Math.floor(Math.min(Math.random()*b.gameMatrix.length, b.gameMatrix.length-20));	
			let randRow = Math.floor(Math.min(Math.random()*b.gameMatrix[randCol].length, b.gameMatrix[randCol].length-20));	

			let glider = [
				b.gameMatrix[randCol][randRow],
				b.gameMatrix[randCol+1][randRow],
				b.gameMatrix[randCol-1][randRow],
				b.gameMatrix[randCol+1][randRow-1],
				b.gameMatrix[randCol][randRow-2]
			]
			glider.forEach((x)=>
				{
				x.state = 1;
				x.draw(1);
			});
			b.updateState();
		},
		createShape:function(shape)
			{
			let randCol = randomNumber(shape.bounds.vertical ,b.gameMatrix.length-shape.bounds.vertical);	
			let randRow = randomNumber(shape.bounds.horizontal, b.gameMatrix[randCol].length-shape.bounds.horizontal);
			shape.imprints.length = 0;
			shape.imprintOnGrid(randCol,randRow);
			shape.imprints.forEach((x)=>
				{
				x.state = 1;
				x.draw(1);
			});
				b.updateState();

		},
		stepForward:function()
			{
			b.gameMatrix.forEach((cellArray)=>
				{
				cellArray.forEach((cell) => 
					{
					if(!cell.cancer)
						{	
						cell.state = cell.gameOfLife(b.canerRate);
					}
					else
						{
						cell.state = cell.gameOfCancer();
					};
					cell.draw(cell.state);
				});
			});
			//now we get the next values after we created a new state
			b.gameMatrix.forEach((cellArray)=>
				{
				cellArray.forEach((cell)=>
					{
			
					cell.updateFriends()
				});
			});
		},
		killCancer: function()
			{
			b.gameMatrix.forEach((cellArray)=>
				{
				cellArray.forEach((cell)=>
					{
					cell.cancer = 0; 
					cell.draw();
				});
			});
			b.gameMatrix.forEach((cellArray)=>
				{
				cellArray.forEach((cell)=>
					{
					cell.updateFriends(); 
				
				});
			});
		},
		seedCancer(val)
			{
			b.gameMatrix.forEach(cellArray=>cellArray.forEach(cell=>cell.setSeededCancer(val)));
		},
		updateState:function()
			{
			b.gameMatrix.forEach(cellArray=>cellArray.forEach(cell=>cell.updateFriends()));

		}

	}

	for(let i = 0; i < width; i++)
		{
		let gameArray = [];	
		for(let j= 0; j < height; j++)
			{	
			let position = {x:i*cellScale,y:j*cellScale};
			let gameCell = createCell(Math.random(), position,i,j, Math.random());
			gameCell.draw();
			gameArray.push(gameCell);
		}
		b.gameMatrix.push(gameArray);	
	}
	b.gameMatrix.forEach((cellArray)=>
		{
		cellArray.forEach((cell)=>
			{	
			let adjacent = [];	
			if(cell.column > 0)
				{
				adjacent.push(b.gameMatrix[cell.column-1].filter(c=>c.row == cell.row-1 ||c.row ==cell.row || c.row == cell.row+1));
			}
			let nextIndexColumn = cell.column+1;
			let nextColumn = b.gameMatrix[nextIndexColumn];
			if(nextColumn)
				{
				adjacent.push(nextColumn.filter(c=>c.row == cell.row ||c.row ==cell.row+1 || c.row==cell.row-1));
			}
			let downNeighbor = cellArray[cell.row+1];
			let upNeigbor = cellArray[cell.row-1];
			if(upNeigbor)
				{
				adjacent.push(upNeigbor);
			}
			if(downNeighbor)
				{
				adjacent.push(downNeighbor);
			}
			adjacent = Flat(adjacent);
			let neightbors = adjacent.map((x)=> { 

				let lastState = x.state;
				let lastCancer = x.cancer;
				let container = [lastState	, x, lastCancer];
				return container;

			});
			neightbors.forEach(neightbor=> cell.neighbors.push(neightbor));
		});
	})
	return b;
}
function Flat(array)
	{
	let holdBucket = [];
	let flatten = function(array)
		{
		for(let i = 0; i<array.length;i++)
			{
			if(Array.isArray(array[i]))
				{
				flatten(array[i]);
			}
			else
				{
				holdBucket.push(array[i]);
			}
		}
	}
	let flatttenedArray = [];
	flatten(array, flatttenedArray);
	return holdBucket;

}
let gameBoard = board(270,480);
function total(array)
	{
	if(array == undefined)
		{
		console.trace(array);	
		}
	let y = 0;
	for(let i=0;i<array.length;i++)
		{
		if(array[i] != NaN || array[i] != undefined)
			{
			y += array[i];
		}
		else
			{
			console.error("not a number");
		}
	}	
	return y;
}
 function randomNumber(min, max) 
 	{  
    min = Math.ceil(min); 
    max = Math.floor(max); 
    return Math.floor(Math.random() * (max - min + 1)) + min; 
}  
  
const engine = function()
	{
		
};	
const turnOn = document.createElement("button");
turnOn.innerHTML = "click me to start";
let on = false;
let saveImageFlag = false;
turnOn.addEventListener('click', function()
	{
	on = true;
	let itteration = 0;	
	const engine = window.setInterval(function()
		{
		gameBoard.stepForward();
		itteration ++;	
		if(saveImageFlag)
			{			 	
			let savedThisImage =  saveImage(itteration,savePath);
			if(!savedThisImage || itteration >= gameBoard.saveCount)
				{
				on = false;
			}
		}
		if(on == false)
			{
			window.clearInterval(engine);
		}
	},200)		
});
function toggle(bool)
	{
	if(bool){bool = false}
	else{bool = true}
		return bool;
}

const cancerOptions = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1];
const turnOff = createButton("PAUSE", function(){on=false;});
const stepButton = createButton('STEP FORWARD', gameBoard.stepForward);
const killCancerButton = createButton('KILL CANCER', gameBoard.killCancer);
const setCancerButton = createButton("SET CANCER",function()
	{
	let cancerInput = document.getElementById('cancerInput');
	let cancerValue = cancerInput.value;
	gameBoard.seedCancer(cancerValue);
	gameBoard.canerRate = cancerValue;
	});
const wipeButton = createButton("WIPE BOARD", gameBoard.wipe);
const saveImagesButton = createButton("START SAVING IMAGES", function()
	{

	toggle(saveImageFlag);
});


	const cancerInput = document.createElement('select');
	cancerInput.setAttribute('id', 'cancerInput');
	cancerInput.innerHTML = "0.001";
	cancerOptions.forEach((option)=>
		{
		let optionE = document.createElement('option');
		optionE.value = option;
		optionE.innerHTML = option;
		cancerInput.add(optionE);
	});

let shapeSelector = document.createElement('select');
	shapeSelector.setAttribute('id', 'shapeSelect');
	shapeSelector.innerHTML = "SHAPE SELECTOR";
	console.log(shapes);
shapes.forEach((shape)=>
	{
	let option = document.createElement('option');
	option.innerHTML = shape.name;
	option.setAttribute('data-shape', shape);
	option.setAttribute('data-shapeIndex', shapes.indexOf(shape));
	shapeSelector.appendChild(option);
});
	shapeSelector.selectedIndex = [0];
const shapeSelectorConfirmButton = createButton("SET THAT SHAPE TO A RANDOM LOCATION", function(){gameBoard.createShape(shapes[shapeSelector[shapeSelector.selectedIndex].getAttribute('data-shapeIndex')])});
const randomShapeCount = document.createElement('input');
	randomShapeCount.setAttribute('type', 'number');
	randomShapeCount.setAttribute('range', "1-10");
	randomShapeCount.value = 1;
	randomShapeCount.setAttribute('id',"count"); 
const randomShapesButton = createButton('CREATE RANDOM SHAPES', function()
	{
	let count = document.getElementById('count').value;	
	for(let i=0; i< count; i++)
		{
		let x = randomNumber(1, shapes.length);	
		gameBoard.createShape(shapes[x]);
	}
});

const body = document.getElementById("body");
const controls = document.createElement('div');
controls.setAttribute('id', 'controls');
body.prepend(controls);
controls.appendChild(turnOn);
controls.appendChild(turnOff);
controls.appendChild(stepButton);
controls.appendChild(wipeButton);
controls.appendChild(cancerInput);
controls.appendChild(setCancerButton);
controls.appendChild(killCancerButton);
controls.appendChild(shapeSelector);
controls.appendChild(shapeSelectorConfirmButton);
controls.appendChild(randomShapeCount);
controls.appendChild(randomShapesButton);
controls.appendChild(saveImagesButton);
</script>
</body>